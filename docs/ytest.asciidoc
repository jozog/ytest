ytest documentation
===================
Rodolphe Saugier <rodolphe.saugier@gmail.com>
v1.0

1. Introduction
---------------

1.1. Purpose
~~~~~~~~~~~~

yTest is a PHP 5 library extending PHPUnit, leveraging the power of the runkit extension
to allow stubbing/mocking things that can't easily changed otherwise:

- private methods.
- static methods.
- functions, including built-in PHP functions.

[[isolation]]
1.2. Isolation in automated testing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When writing automated tests to a project, you need to *isolate* the code
you are testing (often called *SUT*, System Under Test) from other parts of 
the whole system that it depends on (often called *DOC*, Depended-on component).

The SUT can be anything from a method, class, or whole application, depending on
the kind of tests you are writing (unit tests, integration tests, functional tests...).

To isolate the SUT, the DOCs dependencies must be replaced by other "fake" objects
during the automated test. These dummy objects/functions can be configured to return
whatever the SUT needs to work.
Replacing a function or method by a test version is often called "stubbing" or "mocking"
(if it isn't "faking" !).

[NOTE]
=========================================================================================================
Some definitions:

- A *stub* is a static object version designed specifically for a test, returning hard-coded values
specific to the test. 
- A *mock object* is a more elaborate fake object which can be configured to dynamically return values
expected by the SUT during the test, but which can also verify the calls made to it by the SUT.
=========================================================================================================

In a system designed up-front to be tested automatically, there are standard techniques
to help replacing the DOCs by their test versions. The most common is *dependency injection*,
which helps achieve *IOC* (Inversion of Control). The basic principle is easy:
Each dependency of each component of the whole system must be configurable at runtime.
Dependency injection frameworks help achieving this by expliciting all dependencies
in a configuration file.

If you are building a system from scratch, and want to test it automatically,
you probably want to follow IOC principles from the beginning to allow component isolation.
But for legacy systems, there is often no easy way to achieve isolation. This is where
libraries such as runkit and ytest kick in.

1.3. The case of PHP
~~~~~~~~~~~~~~~~~~~~

In most scripting languages, it is possible to redirect at runtime any private method
or function.
For obscure (?) reasons, this is not possible in PHP, which tries to mimic strongly
typed languages in these aspects. You can't rebind an instance method or function
in PHP as you can do it, for example, in Python, where functions are first-class objects:

--------------------------------------------------------------------------------
def myPythonFunction():
    return 42

def someOtherPythonFunction():
    return "foo"

myPythonFunction=someOtherPythonFunction
--------------------------------------------------------------------------------

Hopefully, brave people have created the *runkit* extension which allows to do
such magic things in PHP as well.

*ytest* is a rather simple library built on top of runkit, which makes it easier
to use with *phpunit* tests (If you ever don't know *phpunit*, it's simply the best
implementation of the *xUnit* family of tools for PHP).

2. Setting up ytest and its dependencies
----------------------------------------

2.1 Requirements
~~~~~~~~~~~~~~~~

 - PHP >= 5.2 on GNU/Linux
 - PHPUnit >= 3.4.12
 - runkit ( Actually, the fork which works, by D.Zenovich  https://github.com/zenovich/runkit )
 - MySQL 5 as an optional dependency (required for ytest's sample)

2.2 Make ytest's sample work in your PHP environment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Step 1
^^^^^^

Extract ytest's archive in some folder, say "/home/foo/libs/ytest".
You get something like this:

--------------------------------------
  -- ytest
     |-- config
     |-- docs
     |-- tests
     `-- libs
         `-- ytest
--------------------------------------

Step 2
^^^^^^

Install PHPUnit >= 3.4.12 if you haven't already.  
Assuming PHPUnit's phpunit.php lies in /home/foo/libs/phpunit,
make a symbolic link so that ytest can find it:

  $ cd /home/foo/ytest
  $ ln -s /home/foo/libs/phpunit libs/phpunit

Step 3
^^^^^^

Install the excellent version of runkit by Dmitry Zenovich,
which has great bugfixes included.

You can take the latest version here:
    https://github.com/zenovich/runkit/downloads

You'll have to build runkit yourself, and install it as a PHP extension 
in your system. Here's a quick summary of how to do it (which might be outdated):

-----------------------------------------
  $ cd runkit-1.0.3
  $ phpize
  $ ./configure
  $ make
  $ sudo make install
  $ sudo nano /etc/php5/cli/php.ini
-----------------------------------------

With some editor, add the following lines at the end of your php.ini (for CLI since
the unit tests will be run on the command line):
    
--------------------------------
  extension=runkit.so
  runkit.internal_override=1
--------------------------------

Step 4
^^^^^^

Setup a test database in MySql, or ytest's main self-test won't work:

- Create a database named "ytest".

- Create a user named "ytest" with full privileges on the "ytest" database.

Step 5
^^^^^^

You should be able to run ytest's example test like this:
    $ cd /home/foo/ytest
    $ ./run_tests

You should see something like this:

--------------------------------------------------------
    PHPUnit 3.4.12 by Sebastian Bergmann.

    ...............................

    Time: 0 seconds, Memory: 4.75Mb

    OK (31 tests, 48 assertions)
-------------------------------------------------------

This means that ytest's sample test, tests/FooBarTest.php,
has been executed correctly.
(You can take a look at this test, but it's a bit boring,
you'll probably be better with the ytest docs.)


[[integrating_ytest]]
2.3 Integrating ytest with your own test suite
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now that ytest is functional on your PHP system,
there are two cases:

- If you have no unit tests yet, you can simply add more test files
  along FooBarTest.php in ytest/tests to test your own stuff.
  To access the ytest extensions from your test cases, you simply
  have to make your test cases inherit from yTest_CustomTestCase.
  To run your tests, use the run_tests script.

- If you already have a test suite (and maybe some 
  helper scripts around), you may either:

  * Simply put all your existing test files in ytest/tests,
    and see if it works and suits you. This is the easy way.

  * Or, integrate only the bare ytest library in your system,
    by putting ytest/libs/ytest in your PHP include path.
    In this case you'll have to require the main ytest file
    from your test scripts, for example like this:
+
--
-------------------------------------------------------------------------------------
require_once 'ytest/libs/ytest/ytest.php';
-------------------------------------------------------------------------------------
Then you'll have to initialize ytest at the beginning
of your test suite (like what is done in ytest/Bootstrap.php),
something like this:
-------------------------------------------------------------------------------------
yTest_init("ytest/config/ytest_config.php",   // path to your config file for ytest
	   "ytest/libs/ytest",                // path to the ytest library folder
           "ytest/libs/phpunit"               // path to PHPUnit
          );
-------------------------------------------------------------------------------------
You'll have to tune the folders (and probably use absolute paths).
--

3. Using ytest
--------------

3.1. Example test
~~~~~~~~~~~~~~~~~

After you have integrated ytest in your PHP unit test suite (see <<integrating_ytest, ytest integration chapter>>),
using it becomes very easy.
You simply need to make your test classes inherit from *yTest_CustomTestCase*:

---------------------------------------------------------
class FooBarTest extends yTest_CustomTestCase {
    public function testSomething() {
        // test stuff
    }
}
---------------------------------------------------------

yTest_CustomTestCase exposes almost all of ytest functionality through its instance methods.

3.2. Accessing private members : letMeCall() and letMeAccess()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Suppose we have a simple class with private methods and members:

---------------------------------------------------------

class Foo
{
    private $baz = 42;

    private function bar($arg)
    {
        return $baz * $arg;
    }
}

---------------------------------------------------------

To access baz and bar() in our test, we use letMeCall() and letMeAccess():

---------------------------------------------------------
class FooBarTest extends yTest_CustomTestCase {

    public function testBarBaz() {
        $this->letMeCall("FooBar", "bar");     <1>
        $this->letMeAccess("FooBar", "baz");   <2>

        $foobar = new FooBar();

        $this->assertEquals(42, $this->getProperty($foobar, "baz"); <3>
        $this->setProperty($foobar, "baz", 43);

        $this->assertEquals(86, $foobar->ytx_call_bar(2));  <4>
    }
}
---------------------------------------------------------

<1> *letMeCall(className, methodName)* allows you to call a private/protected instance
    or static method indirectly for the scope of the current test.
<2> *letMeAccess(className, fieldName)* allows you to access private/protected fields
    indirectly for the scope of the current test.
<3> To get/set a private or protected field, use *setProperty()* and *getProperty()*
    after calling letMeAccess()
<4> To call a private/protected method, use the automatically generated proxy method
    *ytx_call_originalMethodName*.

Of course, letMeCall() and letMeAccess() lets you access fields and methods for *all*
instances of a given class. It is not yet possible to restrict the access to a 
specific instance.

Since the effect of letMeCall() or letMeAccess() remains during the current test,
it is a good practice to put these in the *setUp()* method of your test class.
We can therefore rewrite the preceding example this way:

----------------------------------------------------------

class FooBarTest extends yTest_CustomTestCase {

    public function setUp() {
        $this->letMeCall("FooBar", "bar");
        $this->letMeAccess("FooBar", "baz");
    }

    public function testBarBaz() {
        $foobar = new FooBar();

        $this->assertEquals(42, $this->getProperty($foobar, "baz");
        $this->setProperty($foobar, "baz", 43);

        $this->assertEquals(86, $foobar->ytx_call_bar(2));
    }
}

---------------------------------------------------------- 

You can also use letMeCall() and letMeAccess() on static fields and methods,
but the way to do it changes for a few details:

---------------------------------------------------------

class Foo
{
    private static $staticBaz = 42;

    private static function staticBar($arg)
    {
        return $baz * $arg;
    }
}

class FooBarTest extends yTest_CustomTestCase {

    public function setUp() {
        $this->letMeCall("FooBar", "staticBar");
        $this->letMeAccess("FooBar", "staticBaz");
    }

    public function testBarBaz() {
        $foobar = new FooBar();

        $this->assertEquals(42, $this->getStaticProperty($foobar, "staticBaz");   <1>
        $this->setStaticProperty($foobar, "staticBaz", 43);

        $this->assertEquals(86, FooBar::ytx_call_staticBar(2));   <2>
    }
}

---------------------------------------------------------

<1> After calling letMeAccess() the same way as for instance fields,
you have to use *getStaticProperty* and *setStaticProperty* instead
of *getProperty* and *setProperty*.
<2> To call the private static method, use the generated static proxy
    *ytx_call_staticBar* on the class.

[NOTE]
================================================================================
Internally, letMeAccess() also generates some getter and setter methods
that are actually called by getProperty() and setProperty() to set
the target field.

For an instance field called "fooBar" in a class "Foo" these proxies are:

- ytx_get_fooBar() -> value
- ytx_set_fooBar(value)

For a static field "fooBar" the proxies are:

- Foo::ytx_getStatic_fooBar() -> value
- Foo::ytx_setStatic_fooBar(value)

You probably wonder why there is no equivalent of the setProperty()
for calling ytx_call_methodName(), like some *callPrivateMethod()* helper.
Actually, writing a generic method like this seems difficult in PHP,
the problem being the handling of reference parameters.
================================================================================

[WARNING]
================================================================================
ytest uses the magic prefix *ytx_* for all its automatically generated proxy methods.
If your project uses this prefix, you are not completely doomed yet:
you'll have to change it manually in yTest_AbstractCodeChange.php in ytest's sources!
================================================================================

3.3. Rewiring methods
~~~~~~~~~~~~~~~~~~~~~

Method "rewiring" in ytest simply means to rebind it dynamically to another method.
With ytest, you can rewire any class method (static or instance) and any function
to a *public instance method of another object*.
Rewiring to a function is not supported, but is not really needed, since you
can always write some class to achieve what you need.

Here is a simple example of rewiring an *instance method* to another *instance method*,
supposing we want to isolate the system under testd "Foo" from its dependency
"FooDependency" (see the chapter on <<isolation>> for the philosophy behind this).

--------------------------------------------------------------------------------

class Foo
{
    public function doStuff()
    {
        $dep = new Dependency();
        return $dep->bar(2);
    }
}

class Dependency
{
    private $baz = 40;

    private function bar($arg)
    {
        return $baz + $arg;
    }
}

class DummyDependency
{
    public function dummyBar()
    {
        return 38;
    }
}

class FooBarTest extends yTest_CustomTestCase {

    public function testFoo() {
        $foo = new Foo();
        $this->assertEquals(42, $foo->doStuff());   // call the original, we get 40 + 2 = 42

        // now rewire bar()
        $dummy = new DummyDependency();
        $this->rewireMethod("FooDependency", "bar", $dummy, "dummyBar");
        $this->assertEquals(38, $foo->doStuff());   // dummy version gets called
        $this->assertEquals(38, $foo->doStuff());   // dummy version still gets called
    }
}

-------------------------------------------------------------------------------

*rewireMethod(className, originalMethodName, dummyInstance, dummyMethodName)* takes 3 or 4 arguments:

- The name of the class containing the original method to be rewired.
- The name of the original method to be rewired.
- An *object instance* which exposes the dummy method.
- The name of the dummy method, which will receive the calls *instead of* the original method.

[NOTE]
================================================================================
The 4th argument is actually optional: If you omit it, ytest will assume that the 
dummy method has the same name as the original method.
================================================================================